package de.fraunhofer.iem.hybridCG;

import de.fraunhofer.iem.util.DirectedEdge;
import de.fraunhofer.iem.util.EdgesInAGraph;
import de.fraunhofer.iem.util.SerializableUtility;
import de.fraunhofer.iem.util.ZipUtility;
import guru.nidi.graphviz.engine.Format;
import guru.nidi.graphviz.engine.Graphviz;
import soot.*;
import soot.jimple.InvokeExpr;
import soot.jimple.Stmt;
import soot.jimple.toolkits.callgraph.CallGraph;
import soot.jimple.toolkits.callgraph.Edge;
import soot.util.dot.DotGraph;
import soot.util.dot.DotGraphEdge;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

/**
 * This class merges the dynamically generated EdgesInAGraphs into the statically generated call graph
 *
 * @author Ranjith Krishnaurthy
 */
public class HybridCallGraph {
    private DotGraph dotGraph = null;

    /**
     * This method merges the given list of dynamically generated edgesInAGraphs into the statically generated
     * call graph in the Soot scene.
     *
     * @param dtsFileName     Path of the DTS file (dynamic stack trace file)
     * @param staticCallGraph Static call graph generated by the soot
     */
    public void merge(String dtsFileName, CallGraph staticCallGraph) {
        List<EdgesInAGraph> dynamicEdgesInAGraphs = getEdgesInAGraphFromDTSFile(dtsFileName);

        for (EdgesInAGraph edgesInAGraph : dynamicEdgesInAGraphs) {
            for (DirectedEdge directedEdge : edgesInAGraph.getDirectedEdges()) {
                //TODO: For now we left fake edges, consider in the future if want

                // Leave the fake edges
                if (!directedEdge.isFakeEdge()) {
                    SootMethod caller = getMethod(directedEdge.getSource());
                    SootMethod destination = getMethod(directedEdge.getDestination());
                    List<Stmt> statements = getAssociatedCallSiteUnit(caller, directedEdge.getAssociatedCallSite(), directedEdge.getAssociatedCallSiteLineNumber());

                    for (Stmt associatedCallSiteUnit : statements) {
                        boolean isEdgeFound = false;

                        try {
                            for (Iterator<Edge> it = staticCallGraph.edgesOutOf(associatedCallSiteUnit); it.hasNext(); ) {
                                Edge edge = it.next();

                                if (edge.getSrc().method().getSignature().equals(caller.getSignature())) {
                                    if (edge.getTgt().method().getSignature().equals(destination.getSignature())) {
                                        //TODO: Should we have to check for line numbers too?
                                        isEdgeFound = true;
                                    }
                                }
                            }
                        } catch (Exception | Error e) {
                            e.printStackTrace();
                        }

                        if (!isEdgeFound) {
                            Edge edge = new Edge(caller, associatedCallSiteUnit, destination);

                            staticCallGraph.addEdge(edge);
                            DotGraphEdge dotGraphEdge = dotGraph.drawEdge(caller.getSignature(), destination.getSignature());
                            dotGraphEdge.setLabel(associatedCallSiteUnit.toString());
                            dotGraphEdge.setAttribute("color", "purple");
                        }
                    }
                }
            }
        }
    }

    /**
     * This method merges the given list of dynamically generated edgesInAGraphs into the statically generated
     * call graph in the Soot scene. This method also generates the new call graph in dot file and an image with the
     * given image type
     *
     * @param dtsFileName       Path of the DTS file (dynamic stack trace file)
     * @param staticCallGraph   Static call graph generated by the soot
     * @param outputDotFileName File name of the generated dot file of the new call graph
     * @param outputImageName   Image file name of the dot file of the new call graph
     * @param imageType         Image type
     */
    public void merge(String dtsFileName, CallGraph staticCallGraph, String outputDotFileName, String outputImageName, ImageType imageType) {
        merge(dtsFileName, staticCallGraph, outputDotFileName);

        switch (imageType) {
            case SVG:
                saveDotAsSVG(outputDotFileName + ".dot", outputImageName + ".svg", Format.SVG);
                break;
            case PNG:
                saveDotAsSVG(outputDotFileName + ".dot", outputImageName + ".png", Format.PNG);
                break;
        }
    }

    /**
     * This method merges the given list of dynamically generated edgesInAGraphs into the statically generated
     * call graph in the Soot scene. This method also generates the new call graph in dot file and an image in SVG format
     *
     * @param dtsFileName       Path of the DTS file (dynamic stack trace file)
     * @param staticCallGraph   Static call graph generated by the soot
     * @param outputDotFileName File name of the generated dot file of the new call graph
     * @param outputImageName   Image file name of the dot file of the new call graph
     */
    public void merge(String dtsFileName, CallGraph staticCallGraph, String outputDotFileName, String outputImageName) {
        merge(dtsFileName, staticCallGraph, outputDotFileName, outputImageName, ImageType.SVG);
    }

    /**
     * This method merges the given list of dynamically generated edgesInAGraphs into the statically generated
     * call graph in the Soot scene. This method also generates the new call graph in dot file
     *
     * @param dtsFileName       Path of the DTS file (dynamic stack trace file)
     * @param staticCallGraph   Static call graph generated by the soot
     * @param outputDotFileName File name of the generated dot file of the new call graph
     */
    public void merge(String dtsFileName, CallGraph staticCallGraph, String outputDotFileName) {
        dotGraph = new DotGraph("final:callgraph");
        // Generate the initial dot-graph from the static call-graph
        generateDotGraph();

        merge(dtsFileName, staticCallGraph);

        dotGraph.plot(outputDotFileName + ".dot");
    }

    /**
     * Obtain the dynamic traces (EdgesInAGraph object) from the provided DTS file
     *
     * @param dtsFilePath Path of the DTS file
     * @return Dynamic traces (EdgesInAGraph object)
     */
    private List<EdgesInAGraph> getEdgesInAGraphFromDTSFile(String dtsFilePath) {
        List<EdgesInAGraph> edgesInAGraphs = new ArrayList<>();

        for (String filename : ZipUtility.unzipDTSFile(dtsFilePath)) {
            EdgesInAGraph edgesInAGraph = SerializableUtility.deSerialize(filename);

            if (edgesInAGraph == null) {
                System.out.println("ERROR");
            } else {
                edgesInAGraphs.add(edgesInAGraph);
            }
        }

        return edgesInAGraphs;
    }

    /**
     * This method converts the given dot file into image file
     *
     * @param dotFileName         Dot file name
     * @param outputImageFileName Image file name
     * @param format              Image format
     */
    private void saveDotAsSVG(String dotFileName, String outputImageFileName, Format format) {
        try {
            Graphviz.fromFile(new File(dotFileName)).render(format).toFile(new File(outputImageFileName));
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    /**
     * This method generates the dot graph for the call graph present in the Soot scene
     */
    private void generateDotGraph() {
        CallGraph callGraph = Scene.v().getCallGraph();

        for (Edge edge : callGraph) {
            String node_src = edge.getSrc().toString();
            String node_tgt = edge.getTgt().toString();

            if (node_src.startsWith("<java.") || node_tgt.startsWith("<java.")) continue;

            if (node_src.startsWith("<sun.") || node_tgt.startsWith("<sun.")) continue;

            if (node_src.startsWith("<javax.") || node_tgt.startsWith("<javax.")) continue;


            DotGraphEdge dotGraphEdge = dotGraph.drawEdge(node_src, node_tgt);
            dotGraphEdge.setLabel(edge.srcStmt().toString());

        }
    }

    /**
     * This method returns the list of statements in the given caller method that matches the given
     * method (associatedCallSite) and the associatedCallSiteLineNumber
     *
     * @param caller                       Caller method
     * @param associatedCallSite           Associated call site method name inside the given caller method
     * @param associatedCallSiteLineNumber line number of the associated call site method in the given caller method
     * @return List of Soot Stmt
     */
    private List<Stmt> getAssociatedCallSiteUnit(SootMethod caller, String associatedCallSite, int associatedCallSiteLineNumber) {
        ArrayList<Stmt> statements = new ArrayList<>();

        if (caller.hasActiveBody()) {
            Body body = caller.getActiveBody();

            for (Unit unitBox : body.getUnits()) {
                Stmt unit = (Stmt) unitBox;

                if (unit.containsInvokeExpr()) {
                    InvokeExpr invokeExpr = unit.getInvokeExpr();

                    SootMethod callSiteMethod = invokeExpr.getMethod();

                    String methodNameWithClassName = callSiteMethod.getDeclaringClass().getName() + "." + callSiteMethod.getName();

                    StringBuilder parametersTypes = new StringBuilder("(");

                    if (callSiteMethod.getParameterTypes().size() > 0) {
                        for (Type type : callSiteMethod.getParameterTypes()) {
                            parametersTypes.append(type.toString()).append(",");
                        }

                        parametersTypes.setLength(parametersTypes.length() - 1);
                    }

                    parametersTypes.append(")");

                    if (associatedCallSite.contains("(") && associatedCallSite.contains(")")) {
                        String temp = methodNameWithClassName + parametersTypes.toString();

                        System.out.println("Built Signature = " + temp);
                        System.out.println("Associated Call Site = " + associatedCallSite);
                        System.out.println("Line Number = " + associatedCallSiteLineNumber);
                        System.out.println("Original Signature = " + callSiteMethod.getSignature());

                        if (temp.equals(associatedCallSite)) {
                            if (associatedCallSiteLineNumber > 0 && unit.getJavaSourceStartLineNumber() > 0) {
                                if (associatedCallSiteLineNumber == unit.getJavaSourceStartLineNumber()) {
                                    System.out.println("GOOD NEWS");
                                    statements.add(unit);
                                }
                            } else {
                                statements.add(unit);
                            }
                        }
                    } else if (methodNameWithClassName.equals(associatedCallSite)) {
                        if (associatedCallSiteLineNumber > 0 && unit.getJavaSourceStartLineNumber() > 0) {
                            if (associatedCallSiteLineNumber == unit.getJavaSourceStartLineNumber()) {
                                System.out.println("GOOD NEWS");
                                statements.add(unit);
                            }
                        } else {
                            statements.add(unit);
                        }
                    }
                }
            }
        }

        return statements;
    }

    /**
     * Returns the SootMethod of the given method signature
     *
     * @param methodSignature Method signature
     * @return SootMethod
     */
    private SootMethod getMethod(String methodSignature) {
        String[] methodSignatureArray = methodSignature.split("\\(");
        String parameters = methodSignatureArray[1].replaceAll("\\)", "");
        String[] classNameArray = methodSignatureArray[0].split("\\.");
        String methodName = classNameArray[classNameArray.length - 1];
        String className = String.join(".", Arrays.copyOf(classNameArray, classNameArray.length - 1));
        List<Type> types = new ArrayList<>();

        for (String param : parameters.split(",")) {
            if (!param.equals("")) {
                types.add(Scene.v().getType(param));
            }
        }

        SootClass sootClass = Scene.v().forceResolve(className, SootClass.BODIES);

        return sootClass.getMethod(methodName, types);
    }
}
